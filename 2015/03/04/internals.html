<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <link href='/stylesheets/stylesheet.css' rel='stylesheet'>
    <link href='/feed.xml' rel='alternate' title='Atom 1.0' type='application/atom+xml'>
    <link href='/images/favico.png' rel='icon' type='image/png'>
    <link href='/images/favico.ico' rel='shortcut icon' type='image/x-icon'>
    <script src='/javascripts/viewer.js' type='text/javascript'></script>
    <!-- Begin Jekyll SEO tag v1.4.0 -->
<title>Internals - The Crystal Programming Language</title>
<meta property="og:title" content="Internals" />
<meta name="description" content="Let’s talk about what Crystal does with your code: how it represents types in memory,how it does method lookup at runtime, how it does method dispatch, etc. When using a programming language it’s alwaysuseful to know this in order to structure our code in the most efficient way, and to precisely understand what our codewill be transformed to." />
<meta property="og:description" content="Let’s talk about what Crystal does with your code: how it represents types in memory,how it does method lookup at runtime, how it does method dispatch, etc. When using a programming language it’s alwaysuseful to know this in order to structure our code in the most efficient way, and to precisely understand what our codewill be transformed to." />
<link rel="canonical" href="http://crystal-lang.org/2015/03/04/internals.html" />
<meta property="og:url" content="http://crystal-lang.org/2015/03/04/internals.html" />
<meta property="og:site_name" content="The Crystal Programming Language" />
<meta property="og:image" content="http://crystal-lang.org/images/icon.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-03-04T00:00:00-03:00" />
<link rel="next" href="http://crystal-lang.org/2015/04/01/auto.html" title="Auto" />
<link rel="prev" href="http://crystal-lang.org/2015/03/04/crystal-0.6.1-released.html" title="Crystal 0.6.1 released!" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@CrystalLanguage" />
<meta name="twitter:creator" content="@asterite" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Internals",
    "image": "http://crystal-lang.org/images/icon.png",
    "datePublished": "2015-03-04T00:00:00-03:00",
    "description": "Let’s talk about what Crystal does with your code: how it represents types in memory,how it does method lookup at runtime, how it does method dispatch, etc. When using a programming language it’s alwaysuseful to know this in order to structure our code in the most efficient way, and to precisely understand what our codewill be transformed to.",
    "logo": "http://crystal-lang.org/images/crystal-h.png",
    "url": "http://crystal-lang.org/2015/03/04/internals.html"
  }
</script>
<!-- End Jekyll SEO tag -->
  </head>
  <body>
    <div id='fund'>
      <div class='inner'>
        <div class='badge'>
          <a class='text' href='https://www.bountysource.com/teams/crystal-lang/fundraisers/702-crystal-language' target='_blank'>Financie Crystal e ajude a torná-la pronta para produção!</a>
          <a class='text' href='/sponsors'>Conheça nossos patrocinadores</a>
          <a href='https://www.bountysource.com/teams/crystal-lang/fundraisers/702-crystal-language' target='_blank'>
            <img src='https://api.bountysource.com/badge/team?team_id=89730&amp;style=raised'>
          </a>
        </div>
      </div>
    </div>
    <div class='wrapper'>
      <header>
  <div class='logo'>
    <canvas height='216' id='logo-canvas' style='cursor:move' width='216'></canvas>
    <a href='/'>
      <img height='56' src='/images/crystal_logo.png' width='199'>
    </a>
  </div>
  <div id='logo-text'>A Linguagem de Programação</div>
  <nav>
    <ul class='menu'>
      <li>
        <a href='https://github.com/crystal-lang/crystal' target='_blank' title='Git'>
          <i class='ic git'></i>
          <div>GITHUB</div>
        </a>
      </li>
      <li>
        <a href='/docs' target='_blank' title='Docs'>
          <i class='ic bookmark'></i>
          <div>DOCS</div>
        </a>
      </li>
      <li>
        <a href='/api' target='_blank' title='API'>
          <i class='ic download'></i>
          <div>API</div>
        </a>
      </li>
    </ul>
  </nav>
</header>

      <section>
  <h1>Internals</h1>
  <p class='meta'>04 Mar 2015 by asterite</p>
  <p>Let’s talk about what Crystal does with your code: how it represents types in memory,
how it does method lookup at runtime, how it does method dispatch, etc. When using a programming language it’s always
useful to know this in order to structure our code in the most efficient way, and to precisely understand what our code
will be transformed to.</p>

<h2 id="how-types-are-represented-in-memory">How types are represented in memory</h2>

<p>For talking about type representations we will use C and LLVM IR code, so be sure to check <a href="http://llvm.org/docs/LangRef.html#type-system">the reference</a>.</p>

<p>Crystal has built-in types, user defined types and unions.</p>

<h3 id="built-in-types">Built-in types</h3>

<p>These are Nil, Bool, Char and the various number types (Int32, Float64, etc.), Symbol, Pointer, Tuple, StaticArray, Enum, Proc and Class.</p>

<p>Let’s check how a Bool is represented. For this, let’s write this small program:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># test.cr</span>
<span class="n">x</span> <span class="o">=</span> <span class="kp">true</span></code></pre></figure>

<p>To see the generated LLVM we can use this command:</p>

<pre class="code">
crystal build test.cr --emit llvm-ir --prelude=empty
</pre>

<p>The <code class="highlighter-rouge">--emit llvm-ir</code> flag tells the compiler to dump the resulting LLVM IR code to a test.ll file.
The <code class="highlighter-rouge">--prelude=empty</code> tells the compiler to not use
the <a href="https://github.com/crystal-lang/crystal/blob/master/src/prelude.cr">default prelude file</a>, which, for example,
<a href="https://github.com/crystal-lang/crystal/blob/965d6959163717d72cd3703159d60004ebf7f266/src/main.cr#L42">initializes the GC</a>.</p>

<p>In this way we can get a very simple and clean LLVM IR code file with just the code we write:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; ModuleID = 'main_module'</span>

<span class="nv">%String</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i8</span> <span class="p">}</span>

<span class="vg">@symbol_table</span> <span class="p">=</span> <span class="k">global</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="nv">%String</span><span class="p">*]</span> <span class="k">zeroinitializer</span>

<span class="k">define</span> <span class="kt">i1</span> <span class="vg">@__crystal_main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">alloca:</span>
  <span class="nv">%x</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i1</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%entry</span>

<span class="nl">entry:</span>                                            <span class="c1">; preds = %alloca</span>
  <span class="k">store</span> <span class="kt">i1</span> <span class="k">true</span><span class="p">,</span> <span class="kt">i1</span><span class="p">*</span> <span class="nv">%x</span>
  <span class="k">ret</span> <span class="kt">i1</span> <span class="k">true</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@printf</span><span class="p">(</span><span class="kt">i8</span><span class="p">*,</span> <span class="p">...)</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i1</span> <span class="vg">@__crystal_main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="m">0</span>
<span class="p">}</span></code></pre></figure>

<p>The gist is in <code class="highlighter-rouge">__crystal_main</code>: we can see the compiler allocates an <code class="highlighter-rouge">i1</code> in the stack for <code class="highlighter-rouge">x</code> and then stores <code class="highlighter-rouge">true</code> in it.
That is, the compiler represents a Bool as a single bit, which is pretty efficient.</p>

<p>Let’s do the same for an int:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span></code></pre></figure>

<p>For <code class="highlighter-rouge">x</code> this time we will get:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span></code></pre></figure>

<p>In LLVM, and i32 is an int represented with 32 bits, which, again, is pretty efficient and what we would expect the representation
of <code class="highlighter-rouge">Int32</code> to be.</p>

<p>That is, even though Crystal is object-oriented and an Int32 behaves like an object (it has methods), its internal representation
is as efficient as possible.</p>

<h3 id="symbol">Symbol</h3>

<p>Let’s see Symbol now:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">x</span> <span class="o">=</span> <span class="ss">:one</span>
<span class="n">y</span> <span class="o">=</span> <span class="ss">:two</span></code></pre></figure>

<p>Let’s see the full LLVM IR code this time:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; ModuleID = 'main_module'</span>
<span class="k">target</span> <span class="k">datalayout</span> <span class="p">=</span> <span class="s">"e-m:o-i64:64-f80:128-n8:16:32:64-S128"</span>
<span class="k">target</span> <span class="k">triple</span> <span class="p">=</span> <span class="s">"x86_64-apple-darwin14.1.0"</span>

<span class="nv">%String</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i8</span> <span class="p">}</span>

<span class="vg">@one</span> <span class="p">=</span> <span class="k">private</span> <span class="k">constant</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}</span> <span class="p">{</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">3</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">3</span><span class="p">,</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"one\00"</span> <span class="p">}</span>
<span class="vg">@two</span> <span class="p">=</span> <span class="k">private</span> <span class="k">constant</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}</span> <span class="p">{</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">3</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">3</span><span class="p">,</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"two\00"</span> <span class="p">}</span>
<span class="vg">@symbol_table</span> <span class="p">=</span> <span class="k">global</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="nv">%String</span><span class="p">*]</span> <span class="p">[</span><span class="nv">%String</span><span class="p">*</span> <span class="k">bitcast</span> <span class="p">({</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}*</span> <span class="vg">@one</span> <span class="k">to</span> <span class="nv">%String</span><span class="p">*),</span> <span class="nv">%String</span><span class="p">*</span> <span class="k">bitcast</span> <span class="p">({</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}*</span> <span class="vg">@two</span> <span class="k">to</span> <span class="nv">%String</span><span class="p">*)]</span>

<span class="k">define</span> <span class="k">internal</span> <span class="kt">i32</span> <span class="vg">@__crystal_main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">alloca:</span>
  <span class="nv">%x</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="nv">%y</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%entry</span>

<span class="nl">entry:</span>                                            <span class="c1">; preds = %alloca</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span><span class="p">*</span> <span class="nv">%x</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i32</span><span class="p">*</span> <span class="nv">%y</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="m">1</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@printf</span><span class="p">(</span><span class="kt">i8</span><span class="p">*,</span> <span class="p">...)</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@__crystal_main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="m">0</span>
<span class="p">}</span></code></pre></figure>

<p>Three things are important here. First, we can see that a Symbol is represented as <code class="highlighter-rouge">i32</code>, that is, with four bytes. Second,
we can see <code class="highlighter-rouge">x</code> is assigned a value of 0 and <code class="highlighter-rouge">y</code> is assigned a value of 1. Third, we can see some constants at the top:
<code class="highlighter-rouge">hello</code>, <code class="highlighter-rouge">bye</code> and <code class="highlighter-rouge">symbol_table</code>.</p>

<p>Basically, a Symbol in Crystal is just a name assigned to a unique number. A Symbol can’t be created dynamically
(there’s no <code class="highlighter-rouge">String#to_sym</code>) and the only way to create them is with their literal value, so the compiler can know
all the symbols used across the program. The compiler assigns a number to each of them, starting from zero, and it also
builds a table that map their number to a string, to be able to implement <code class="highlighter-rouge">Symbol#to_s</code> in a very efficient way.
This makes symbols very attractive to use for small groups of constants, because it’s like using magic numbers but with names instead.</p>

<h3 id="pointer">Pointer</h3>

<p>A Pointer is a generic type that represents a typed pointer to some memory location. For example:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">x</span> <span class="o">=</span> <span class="no">Pointer</span><span class="p">(</span><span class="no">Int32</span><span class="p">).</span><span class="nf">malloc</span><span class="p">(</span><span class="mi">1</span><span class="n">_u64</span><span class="p">)</span>
<span class="n">x</span><span class="p">.</span><span class="nf">value</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">x</span><span class="p">.</span><span class="nf">value</span> <span class="c1">#=&gt; 1</span></code></pre></figure>

<p>If you look at the generated LLVM IR code you will see a bunch of code. First, <code class="highlighter-rouge">x</code> is represented like this:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span><span class="p">*</span></code></pre></figure>

<p>Again, this is just a pointer to an int32, as it should be. Next you will see a call to <code class="highlighter-rouge">malloc</code> (will ask memory from the GC
using the regular prelude) and <code class="highlighter-rouge">memset</code> to clear the memory, and then some instructions to assign 1 in that memory address.
This is not very important for the subject of this blog post, so we skip it, but it’s important to know that generated code
is very similar to what would be generated in C.</p>

<h3 id="tuple">Tuple</h3>

<p>A Tuple is a fixed-size, immutable sequence of values, where the types at each position are known at compile time.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="kp">true</span><span class="p">}</span></code></pre></figure>

<p>Pieces of LLVM IR code for the above are:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%"{Int32, Bool}"</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span>
<span class="p">...</span>
<span class="nv">%x</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%"{Int32, Bool}"</span></code></pre></figure>

<p>As we can see, a tuple is represented as an <a href="http://llvm.org/docs/LangRef.html#structure-type">LLVM structure</a>, which just
packs values sequentially. This representation of tuples allows us, for example, to decompose an Int32 into its bytes,
in this way:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">x</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">pointerof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">as</span> <span class="p">{</span><span class="no">UInt8</span><span class="p">,</span> <span class="no">UInt8</span><span class="p">,</span> <span class="no">UInt8</span><span class="p">,</span> <span class="no">UInt8</span><span class="p">}</span><span class="o">*</span>
<span class="nb">puts</span> <span class="n">ptr</span><span class="p">.</span><span class="nf">value</span> <span class="c1">#=&gt; {21, 205, 91, 7}</span></code></pre></figure>

<h3 id="staticarray">StaticArray</h3>

<p>A StaticArray is a fixed-size, mutable sequence of values of a same type, allocated on the stack and passed by value.
The prelude includes safe ways to create them, but since we are using a bare-bones prelude an unsafe (will be initialized
to data containing garbage) way to create them is this:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">x</span> <span class="o">=</span> <span class="n">uninitialized</span> <span class="no">Int32</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span></code></pre></figure>

<p>Its LLVM representation:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">8</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span></code></pre></figure>

<p>We won’t talk much more about this type because it’s not used that much, mostly for IO buffers and such: Array is the
recommended type for all other operations.</p>

<h3 id="enum">Enum</h3>

<p>Here’s an enum:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">enum</span> <span class="no">Color</span>
  <span class="no">Red</span>
  <span class="no">Green</span>
  <span class="no">Blue</span>
<span class="k">end</span>

<span class="n">x</span> <span class="o">=</span> <span class="no">Color</span><span class="o">::</span><span class="no">Green</span></code></pre></figure>

<p>An enum is, in a way, similar to Symbol: numbers associated to names so we can use names in our code instead of
magic numbers. As expected, an enum is represented as an i32, that is four bytes, unless specified otherwise
in its declaration:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">enum</span> <span class="no">Color</span> <span class="p">:</span> <span class="no">UInt8</span>
  <span class="no">Red</span>
  <span class="no">Green</span>
  <span class="no">Blue</span>
<span class="k">end</span></code></pre></figure>

<p>The nice thing about enums is that you can print them and you get their name, not their value:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">puts</span> <span class="no">Color</span><span class="o">::</span><span class="no">Green</span> <span class="c1">#=&gt; Green</span></code></pre></figure>

<p>This is done in a different way than with Symbol, <a href="https://github.com/crystal-lang/crystal/blob/965d6959163717d72cd3703159d60004ebf7f266/src/enum.cr#L4">using compile-time reflection and macros</a>.
But, basically, an enum’s <code class="highlighter-rouge">to_s</code> method is generated only when needed. But it’s nice that an enum is memory and speed efficient
and also comfortable to use and to debug with (like, you get names instead of numbers when printing them).</p>

<h3 id="proc">Proc</h3>

<p>A Proc is a function pointer with an optional closure data information. For example:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">f</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="no">Int32</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span></code></pre></figure>

<p>This is a function pointer that receives an Int32 and returns an Int32. Since it doesn’t capture any local variables
it’s not a closure. But the compiler still represents it like this:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%"-&gt;"</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i8</span><span class="p">*,</span> <span class="kt">i8</span><span class="p">*</span> <span class="p">}</span></code></pre></figure>

<p>That is a pair of pointers: one containing the pointer to the real function, another one containing a pointer to the
closured data.</p>

<p>The LLVM IR code for the above is:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; ModuleID = 'main_module'</span>

<span class="nv">%String</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i8</span> <span class="p">}</span>
<span class="nv">%"-&gt;"</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i8</span><span class="p">*,</span> <span class="kt">i8</span><span class="p">*</span> <span class="p">}</span>

<span class="vg">@symbol_table</span> <span class="p">=</span> <span class="k">global</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="nv">%String</span><span class="p">*]</span> <span class="k">zeroinitializer</span>

<span class="k">define</span> <span class="nv">%"-&gt;"</span> <span class="vg">@__crystal_main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">alloca:</span>
  <span class="nv">%f</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%"-&gt;"</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%"-&gt;"</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%entry</span>

<span class="nl">entry:</span>                                            <span class="c1">; preds = %alloca</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="nv">%"-&gt;"</span><span class="p">*</span> <span class="nv">%0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="k">store</span> <span class="kt">i8</span><span class="p">*</span> <span class="k">bitcast</span> <span class="p">(</span><span class="kt">i32</span> <span class="p">(</span><span class="kt">i32</span><span class="p">)*</span> <span class="vg">@"~fun_literal_1"</span> <span class="k">to</span> <span class="kt">i8</span><span class="p">*),</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%1</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="nv">%"-&gt;"</span><span class="p">*</span> <span class="nv">%0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="k">store</span> <span class="kt">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%2</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%"-&gt;"</span><span class="p">*</span> <span class="nv">%0</span>
  <span class="k">store</span> <span class="nv">%"-&gt;"</span> <span class="nv">%3</span><span class="p">,</span> <span class="nv">%"-&gt;"</span><span class="p">*</span> <span class="nv">%f</span>
  <span class="k">ret</span> <span class="nv">%"-&gt;"</span> <span class="nv">%3</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@printf</span><span class="p">(</span><span class="kt">i8</span><span class="p">*,</span> <span class="p">...)</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%"-&gt;"</span> <span class="vg">@__crystal_main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">define</span> <span class="k">internal</span> <span class="kt">i32</span> <span class="vg">@"~fun_literal_1"</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%0</span>
<span class="p">}</span></code></pre></figure>

<p>A bit harder to digest than the above examples, but it’s basically assining a pointer to <code class="highlighter-rouge">~fun_literal_1</code> in the first
position and <code class="highlighter-rouge">null</code> in the second. If our Proc captures a local variable:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="no">Int32</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a</span> <span class="p">}</span></code></pre></figure>

<p>The LLVM IR code changes:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; ModuleID = 'main_module'</span>

<span class="nv">%String</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i8</span> <span class="p">}</span>
<span class="nv">%"-&gt;"</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i8</span><span class="p">*,</span> <span class="kt">i8</span><span class="p">*</span> <span class="p">}</span>
<span class="nv">%closure</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i32</span> <span class="p">}</span>

<span class="vg">@symbol_table</span> <span class="p">=</span> <span class="k">global</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="nv">%String</span><span class="p">*]</span> <span class="k">zeroinitializer</span>

<span class="k">define</span> <span class="nv">%"-&gt;"</span> <span class="vg">@__crystal_main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">alloca:</span>
  <span class="nv">%f</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%"-&gt;"</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%"-&gt;"</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%entry</span>

<span class="nl">entry:</span>                                            <span class="c1">; preds = %alloca</span>
  <span class="nv">%malloccall</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="kt">i8</span><span class="p">*</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i32</span> <span class="k">ptrtoint</span> <span class="p">(</span><span class="kt">i32</span><span class="p">*</span> <span class="k">getelementptr</span> <span class="p">(</span><span class="kt">i32</span><span class="p">*</span> <span class="k">null</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">)</span> <span class="k">to</span> <span class="kt">i32</span><span class="p">))</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">i8</span><span class="p">*</span> <span class="nv">%malloccall</span> <span class="k">to</span> <span class="nv">%closure</span><span class="p">*</span>
  <span class="nv">%a</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="nv">%closure</span><span class="p">*</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i32</span><span class="p">*</span> <span class="nv">%a</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="nv">%closure</span><span class="p">*</span> <span class="nv">%1</span> <span class="k">to</span> <span class="kt">i8</span><span class="p">*</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="nv">%"-&gt;"</span><span class="p">*</span> <span class="nv">%0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="k">store</span> <span class="kt">i8</span><span class="p">*</span> <span class="k">bitcast</span> <span class="p">(</span><span class="kt">i32</span> <span class="p">(</span><span class="kt">i8</span><span class="p">*,</span> <span class="kt">i32</span><span class="p">)*</span> <span class="vg">@"~fun_literal_1"</span> <span class="k">to</span> <span class="kt">i8</span><span class="p">*),</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%3</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="nv">%"-&gt;"</span><span class="p">*</span> <span class="nv">%0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="k">store</span> <span class="kt">i8</span><span class="p">*</span> <span class="nv">%2</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%4</span>
  <span class="nv">%5</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%"-&gt;"</span><span class="p">*</span> <span class="nv">%0</span>
  <span class="k">store</span> <span class="nv">%"-&gt;"</span> <span class="nv">%5</span><span class="p">,</span> <span class="nv">%"-&gt;"</span><span class="p">*</span> <span class="nv">%f</span>
  <span class="k">ret</span> <span class="nv">%"-&gt;"</span> <span class="nv">%5</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@printf</span><span class="p">(</span><span class="kt">i8</span><span class="p">*,</span> <span class="p">...)</span>

<span class="k">declare</span> <span class="k">noalias</span> <span class="kt">i8</span><span class="p">*</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%"-&gt;"</span> <span class="vg">@__crystal_main</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%argc</span><span class="p">,</span> <span class="kt">i8</span><span class="p">**</span> <span class="nv">%argv</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">define</span> <span class="k">internal</span> <span class="kt">i32</span> <span class="vg">@"~fun_literal_1"</span><span class="p">(</span><span class="kt">i8</span><span class="p">*,</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">i8</span><span class="p">*</span> <span class="nv">%0</span> <span class="k">to</span> <span class="nv">%closure</span><span class="p">*</span>
  <span class="nv">%a</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="nv">%closure</span><span class="p">*</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">i8</span><span class="p">*</span> <span class="nv">%0</span> <span class="k">to</span> <span class="nv">%closure</span><span class="p">*</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">*</span> <span class="nv">%a</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="nv">%3</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%4</span>
<span class="p">}</span></code></pre></figure>

<p>This is even harder to digest, but basically some memory is asked that will contain the value of the variable <code class="highlighter-rouge">a</code>, and
the Proc receives it and uses it. In this case the memory is asked with <code class="highlighter-rouge">malloc</code>, but with the regular prelude the memory
will be allocated by the GC and released when no longer needed.</p>

<h3 id="class">Class</h3>

<p>Classes are objects too:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">x</span> <span class="o">=</span> <span class="no">Int32</span></code></pre></figure>

<p>Not surprisingly, a class is represented as an Int32:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="sx">%x = </span><span class="n">alloca</span> <span class="n">i32</span>
<span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">store</span> <span class="n">i32</span> <span class="mi">45</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">x</span></code></pre></figure>

<p>Because classes can’t be created at runtime, and the compiler knows all classes, it assigns a type id to them
and that way it can identify them.</p>

<h2 id="user-defined-types">User-defined types</h2>

<p>Users can define classes and structs. The difference is that newing a class allocates it on the heap, and a pointer
to that data is passed across variables and methods, while newing a struct allocates that memory on the stack and the whole
struct’s value is passed, copied, across variables and methods.</p>

<p>Let’s try it:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Point</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="vi">@x</span><span class="p">,</span> <span class="vi">@y</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">x</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></code></pre></figure>

<p>The LLVM IR code contains:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Point</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span> <span class="p">}</span>
<span class="p">...</span>
<span class="nv">%x</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%Point</span><span class="p">*</span></code></pre></figure>

<p>Mmm… wait! A Point has just two instance variables, <code class="highlighter-rouge">@x</code> and <code class="highlighter-rouge">@y</code>, both of type Int32, so why there’s another <code class="highlighter-rouge">i32</code>
there? Well, it turns out Crystal adds an Int32 to store a type id associated with the class. This doesn’t make much sense
right now, but when we’ll talk about how unions are represented it will make more sense.</p>

<p>Let’s see the same for a struct:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">struct</span> <span class="no">Point</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="vi">@x</span><span class="p">,</span> <span class="vi">@y</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">x</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></code></pre></figure>

<p>The LLVM IR code contains:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Point</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span> <span class="p">}</span>
<span class="p">...</span>
<span class="nv">%x</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%Point</span></code></pre></figure>

<p>In this case a struct doesn’t contain the extra Int32 field for the type id.</p>

<p>Now comes the fun part: unions!</p>

<h2 id="unions">Unions</h2>

<p>Crystal supports unions of arbitrary types. For example you can have a variable that has either an Int32 or a Bool:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">else</span>
  <span class="n">x</span> <span class="o">=</span> <span class="kp">false</span>
<span class="k">end</span></code></pre></figure>

<p>At the end of the <code class="highlighter-rouge">if</code> the variable <code class="highlighter-rouge">x</code> will either be <code class="highlighter-rouge">3</code> or <code class="highlighter-rouge">false</code>, which makes it type an Int32 or a Bool.
The Crystal way to talk about a union is using a pipe, like this: <code class="highlighter-rouge">Int32 | Bool</code>. In the LLVM IR code we can find:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%"(Int32 | Bool)"</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">1</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="p">}</span>
<span class="p">...</span>
<span class="nv">%x</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%"(Int32 | Bool)"</span></code></pre></figure>

<p>We can see that the representation of this particular union is an LLVM structure containing two fields. The first
one will contain the type id of the value. The second one is the value itself, which is a bit array as large as
the largest type in that union (due to some alignment concerns, the size is extended to 64 bits boundaries in 64 bit
architectures). In C it would be:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">Int32OrBool</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">type_id</span><span class="p">;</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">int_value</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">bool_value</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure>

<p>The first field, the type id, will be used by the compiler when you invoke a method on <code class="highlighter-rouge">x</code>.</p>

<p>So, it would seem that here ends the story about how union types are represented. However, there are some unions
that are very common: nilable types.</p>

<p>We didn’t talk about Nil previously, but since it can only contain a single value, and you can’t use <code class="highlighter-rouge">void</code> for a value,
its represented as i1:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">x</span> <span class="o">=</span> <span class="kp">nil</span> <span class="c1"># %x = alloca i1</span></code></pre></figure>

<p>Let’s make now a union of nil and a class:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span>
  <span class="n">x</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">else</span>
  <span class="n">x</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>If we check the LLVM IR code we will see this for x:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%Point</span><span class="p">*</span></code></pre></figure>

<p>So a union of <code class="highlighter-rouge">Point | Nil</code>, where Point is a class, is represented in the same was as the Point class. How can
we tell if x is Nil or Point? Easy: a null pointer means it’s Nil, a non-null pointer means it’s a Point.</p>

<p>In fact, all unions that only involve classes and/or nil are always represented as a single pointer. If it’s
a null pointer, it’s Nil. Otherwise, if the union contains many possible classes, we can know the type with the
first member of the value, an Int32, remember? Having all of these unions be represented as pointers makes the
code much more efficient, as pointers fit in registers and occupy very little memory.</p>

<p>However, a union of Nil and a struct will always be represented as a tagged union, like the <code class="highlighter-rouge">Int32 | Bool</code> case.
But these unions are much less common.</p>

<p>Now that we understand how types are represented and how, at runtime, we can know what type is contained in a
union, let’s talk about method dispatch.</p>

<h2 id="method-dispatch">Method dispatch</h2>

<p>Although Crystal is object-oriented, method lookup and dispatch work very different than other object-oriented
languages. For example, there are no virtual tables and no metadata stored for types (except that type id field we
talked before). We try to minimize the runtime data needed for a program to work, and also maximize its speed of
execution, sometimes sacrificing the resulting binary size (which doesn’t grow a lot, either). For example, let’s
consider this class hierarchy:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Moo</span>
  <span class="k">def</span> <span class="nf">foo</span>
    <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Foo</span>
  <span class="k">def</span> <span class="nf">foo</span>
    <span class="mi">2</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Bar</span> <span class="o">&lt;</span> <span class="no">Foo</span>
  <span class="kp">include</span> <span class="no">Moo</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Baz</span> <span class="o">&lt;</span> <span class="no">Bar</span>
<span class="k">end</span>

<span class="no">Baz</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">foo</span> <span class="c1">#=&gt; 1</span></code></pre></figure>

<p>Wow, a big class hierarchy and even an included module, and two definitions for <code class="highlighter-rouge">foo</code>. By looking at the code,
can you know which <code class="highlighter-rouge">foo</code> method will get invoked in this case?</p>

<p>…</p>

<p>Well, it’s <code class="highlighter-rouge">Moo#foo</code>, right? Yes, indeed. Well, it turns out the compiler knows this too, and if you take a look
at the generated code you will see something like this:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; Create a Bar</span>
<span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Baz</span><span class="p">*</span> <span class="vg">@"*Baz::new:Baz"</span><span class="p">()</span>
<span class="c1">; Invoke Moo#foo: no method lookup</span>
<span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@"*Baz@Moo#foo&lt;Baz&gt;:Int32"</span><span class="p">(</span><span class="nv">%Baz</span><span class="p">*</span> <span class="nv">%0</span><span class="p">)</span>

<span class="p">...</span>

<span class="k">define</span> <span class="k">internal</span> <span class="kt">i32</span> <span class="vg">@"*Baz@Moo#foo&lt;Baz&gt;:Int32"</span><span class="p">(</span><span class="nv">%Baz</span><span class="p">*</span> <span class="nv">%self</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="m">1</span>
<span class="p">}</span></code></pre></figure>

<p>What happens if we create an instance of Bar and we invoke <code class="highlighter-rouge">foo</code> on it too:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Bar</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">foo</span>
<span class="no">Baz</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">foo</span></code></pre></figure>

<p>Now the LLVM IR code contains this:</p>

<figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Bar</span><span class="p">*</span> <span class="vg">@"*Bar::new:Bar"</span><span class="p">()</span>
<span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@"*Bar@Moo#foo&lt;Bar&gt;:Int32"</span><span class="p">(</span><span class="nv">%Bar</span><span class="p">*</span> <span class="nv">%0</span><span class="p">)</span>
<span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Baz</span><span class="p">*</span> <span class="vg">@"*Baz::new:Baz"</span><span class="p">()</span>
<span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@"*Baz@Moo#foo&lt;Baz&gt;:Int32"</span><span class="p">(</span><span class="nv">%Baz</span><span class="p">*</span> <span class="nv">%2</span><span class="p">)</span>
<span class="p">...</span>
<span class="k">define</span> <span class="k">internal</span> <span class="kt">i32</span> <span class="vg">@"*Bar@Moo#foo&lt;Bar&gt;:Int32"</span><span class="p">(</span><span class="nv">%Bar</span><span class="p">*</span> <span class="nv">%self</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="m">1</span>
<span class="p">}</span>

<span class="k">define</span> <span class="k">internal</span> <span class="kt">i32</span> <span class="vg">@"*Baz@Moo#foo&lt;Baz&gt;:Int32"</span><span class="p">(</span><span class="nv">%Baz</span><span class="p">*</span> <span class="nv">%self</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="m">1</span>
<span class="p">}</span></code></pre></figure>

<p>Oops, isn’t there a duplicated definition of <code class="highlighter-rouge">foo</code> there? Well, yes. You can think as if the compiler
copied foo’s definition into each class, and so there will be, indeed, many copies of the same method.
But this doesn’t matter much: most methods are not big, and method call speed is much more important. Furthermore,
small methods get inlined anyway in an optimized build, and there’s even an LLVM transformation pass to
detect duplicated functions and merge them.</p>

<p>Of course, the story changes a bit if <code class="highlighter-rouge">Moo#foo</code> invokes an instance method or uses an instance variable. In this
case the “duplicated” methods will actually be different, again, as if we copied each method definition
into each type that finally contains it. This makes method call as efficient as possible, at the cost
of (possibly) increasing executable size. But end users are usually more concerned about speed than
executable size.</p>

<p>All of the above is possible because the compiler knows the exact type of <code class="highlighter-rouge">Bar.new</code>. What happens
if the compiler doesn’t know this? Let’s start with a simple union where types are not classes
in the same hierarchy:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Foo</span>
  <span class="k">def</span> <span class="nf">foo</span>
    <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Bar</span>
  <span class="k">def</span> <span class="nf">foo</span>
    <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span>
  <span class="n">obj</span> <span class="o">=</span> <span class="no">Foo</span><span class="p">.</span><span class="nf">new</span>
<span class="k">else</span>
  <span class="n">obj</span> <span class="o">=</span> <span class="no">Bar</span><span class="p">.</span><span class="nf">new</span>
<span class="k">end</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">foo</span></code></pre></figure>

<p>This time the compiler will generate code that more or less does this: before invoking <code class="highlighter-rouge">foo</code> on <code class="highlighter-rouge">obj</code>,
check what type is <code class="highlighter-rouge">obj</code>. This can be known by loading the first field (the type id) of the pointer
that represents the object. Then based on this we invoke one method or another. The decision for this
is just one memory load and a comparison: very efficient. For a bigger union it would still be one memory
load or just reading the type id field of a union, and then many comparisons. But… wouldn’t a lookup
table be faster?</p>

<p>Well, it turns out LLVM is pretty smart, and when it detects many comparisons it can sometimes build a
lookup table for us. For this to work better, the numbers inside the lookup table must be close to each
other (imagine a lookup table for the values 1 and 1000000, it would take a lot of space so LLVM would
decide to do comparisons in that case). Luckily, we assign type ids in a way that helps LLVM
achieve this.</p>

<p>When we say <code class="highlighter-rouge">big unions</code> chances are that that union contains classes of the same hierarchy: you usually
build a class hierarchy to make all types follow a certain rule, respond to a similar set of methods.
Although you can do this without a class hierarchy, they are a very common way of structuring code.</p>

<p>Consider this class hierarchy:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Foo</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">Bar</span> <span class="o">&lt;</span> <span class="no">Foo</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">Baz</span> <span class="o">&lt;</span> <span class="no">Bar</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">Qux</span> <span class="o">&lt;</span> <span class="no">Bar</span><span class="p">;</span> <span class="k">end</span></code></pre></figure>

<p>Considering these types only, the compiler assigns type ids in a post-order way: first Baz gets assigned
1, then Qux gets assigned 2, then Bar gets assigned 3, and finally Foo gets assigned 4. Also, the compiler
tracks the range of type ids of a type’s subtypes, including itself, so for Bar it also assigns the
range 1-3, and for Foo it assigns the range 1-4.</p>

<p>Now, consider this:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Foo</span>
  <span class="k">def</span> <span class="nf">foo</span>
    <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Bar</span> <span class="o">&lt;</span> <span class="no">Foo</span>
  <span class="k">def</span> <span class="nf">foo</span>
    <span class="mi">2</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Baz</span> <span class="o">&lt;</span> <span class="no">Bar</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">Qux</span> <span class="o">&lt;</span> <span class="no">Bar</span><span class="p">;</span> <span class="k">end</span>

<span class="n">obj</span> <span class="o">=</span> <span class="c1"># ... a union of the above types</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">foo</span></code></pre></figure>

<p>First, the compiler will type <code class="highlighter-rouge">obj</code> as <code class="highlighter-rouge">Foo+</code>, meaning it can be Foo or one of its sublcasses (read
more about this <a href="http://crystal-lang.org/docs/syntax_and_semantics/virtual_and_abstract_types.html">here</a>).
In this case, there will be only two different method instantiations: one for <code class="highlighter-rouge">Foo+</code> and one for <code class="highlighter-rouge">Bar+</code>, since
Baz and Qux don’t redefine that method. To know which one we need to call, we load the type id. Then, instead
of having to say “if the type id is that of Bar, or Baz or Qux, call Bar#foo, otherwise call Foo#foo`, we
can simply check if the type id is in the range previously assigned to Bar (1-3): just two comparisons.</p>

<p>This range check also works with <code class="highlighter-rouge">is_a?</code>. When you do <code class="highlighter-rouge">obj.is_a?(Foo)</code>, and maybe <code class="highlighter-rouge">obj</code> is an Int32 or, Foo,
or one of its subclasses, we can solve this with at most two comparisons.</p>

<p>Finally, an interesting aspect of Crystal is that method dispatch happens based on possibly many types:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="no">Int32</span><span class="p">,</span> <span class="n">y</span> <span class="p">:</span> <span class="no">Char</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="no">Char</span><span class="p">,</span> <span class="n">y</span> <span class="p">:</span> <span class="no">Int32</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">foo</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'a'</span></code></pre></figure>

<p>And this also works if the type of all arguments is not known at compile time. But… this blog post is getting a bit
long and complex by now: there are many more micro-optimizations that we apply to your
code to make it as efficient as possible. So don’t be afraid to use Crystal to its full potential :-)</p>

  <div id='disqus_thread'></div>
  <script>
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'crystal-lang'; // required: replace example with your forum shortname
    var disqus_identifier = '/2015/03/04/internals';
    var disqus_title = "Internals";
    var disqus_url = "http://br.crystal-lang.org//2015/03/04/internals.html";
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>
    Por favor ative o JavaScript para ver os
    <a href='http://disqus.com/?ref_noscript'>comentários do Disqus.</a>
  </noscript>
  <a class='dsq-brlink' href='http://disqus.com'>
    comments powered by
    <span class='logo-disqus'>Disqus</span>
  </a>
</section>

      <footer>
  <a href='http://www.manas.com.ar' target='_blank'>
    <img height='34' src='/images/born-and-raised.svg' width='100'>
  </a>
</footer>

    </div>
    <script>
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script>
  try {
    var pageTracker = _gat._getTracker("UA-42353458-1");
    pageTracker._trackPageview();
  } catch(err) {}
</script>

    <script src='/javascripts/main.js' type='text/javascript'></script>
  </body>
</html>
